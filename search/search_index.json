{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yet Another Guide to C Pointers Introduction Introduction to c pointer Visualization Visualization of pointers and targets Workflow Workflow for using pointers correctly","title":"Home"},{"location":"#yet-another-guide-to-c-pointers","text":"","title":"Yet Another Guide to C Pointers"},{"location":"#introduction","text":"Introduction to c pointer","title":"Introduction"},{"location":"#visualization","text":"Visualization of pointers and targets","title":"Visualization"},{"location":"#workflow","text":"Workflow for using pointers correctly","title":"Workflow"},{"location":"introduction/","text":"Goal of the Docs The pointer in C is powerful but confusing. We can understand pointer better if we think it logically and use it concisely. This document is trying to bridge the gap between logic thinking and concise usage. Target of a Pointer The target of a pointer could be NULL, a normal variable, a pointer variable, a function, an array, a structure, or a string. The target must be defined first, assign its address to a pointer, then use the pointer to indirectly access the target. Dimensional Analysis Pointers are used to store memory address. Dereferencing pointers can access memory content including data, address, and code. Description Memory Address and Content int v; // v is an integer variable int a[5]; // a[] is an array with 5 integer variables a[0], a[1], ..., a[4] int *p; // p is an integer pointer int f(); // f() is a function which returns an integer Memory Address constant address &v : address of variable v constant address &p : address of pointer p constant address a : address of an array a[] ( & is NOT needed for an array) constant address f : address of a function f() ( & is NOT needed for a function) Memory Content variable v : memory content as data pointer p : memory content as address function f() : memory content as code Assign a memory address to a pointer. pointer assignment p = memory address ... DA OK pointer assignment p = data ... DA NG Dereference a pointer to access data. dereferencing pointer *p = data ... DA OK dereferencing pointer *p = address ... DA NG dereferencing pointer data = *p ... DA OK Examples 1. Pointer to Data data_type v, *pv; pv = &v; // v is a variable, &v is its address data_type a[5], *pa; pa = &a[0] // think logically: a[0] is a variable, &a[0] is its address pa = a // use concisely: a is array name and a = &a[0] v: a normal variable pv: a pointer to a variable v a[]: an array of variables a: array name pa: a pointer to an array address constant address (assigned by compiler): &v , &pv , a , &a[0] , &a[1] , ... changeable address variable (changeable during runtime): pv , pa data direct access: v , a[0] , a[1] , ..., f() indirect access: *pv , *pa , pa[0] , *(pa+1) , pa[1] , ..., (*pf)() 2. Pointer to Function data_type fd(), (*pfd)(); pfd = &fd; // thinking pfd = fd; // usage data_type *fa(), *(*pfa)(); pfa = &fa; pfa = fa; fd(): a function that returns data fd: function name pfd: a pointer to a funciton fd() fa(): a function that returns address fa: function name pfa: a pointer to a function fa() address constant address: &fd , fd , &fa , fa changeable address variable: pfd , pfa address returned by fa(): fa() , (*pfa)() data data returned by fd(): fd() , (*pfd)()","title":"Introduction"},{"location":"introduction/#goal-of-the-docs","text":"The pointer in C is powerful but confusing. We can understand pointer better if we think it logically and use it concisely. This document is trying to bridge the gap between logic thinking and concise usage.","title":"Goal of the Docs"},{"location":"introduction/#target-of-a-pointer","text":"The target of a pointer could be NULL, a normal variable, a pointer variable, a function, an array, a structure, or a string. The target must be defined first, assign its address to a pointer, then use the pointer to indirectly access the target.","title":"Target of a Pointer"},{"location":"introduction/#dimensional-analysis","text":"Pointers are used to store memory address. Dereferencing pointers can access memory content including data, address, and code.","title":"Dimensional Analysis"},{"location":"introduction/#description","text":"","title":"Description"},{"location":"introduction/#memory-address-and-content","text":"int v; // v is an integer variable int a[5]; // a[] is an array with 5 integer variables a[0], a[1], ..., a[4] int *p; // p is an integer pointer int f(); // f() is a function which returns an integer Memory Address constant address &v : address of variable v constant address &p : address of pointer p constant address a : address of an array a[] ( & is NOT needed for an array) constant address f : address of a function f() ( & is NOT needed for a function) Memory Content variable v : memory content as data pointer p : memory content as address function f() : memory content as code","title":"Memory Address and Content"},{"location":"introduction/#assign-a-memory-address-to-a-pointer","text":"pointer assignment p = memory address ... DA OK pointer assignment p = data ... DA NG","title":"Assign a memory address to a pointer."},{"location":"introduction/#dereference-a-pointer-to-access-data","text":"dereferencing pointer *p = data ... DA OK dereferencing pointer *p = address ... DA NG dereferencing pointer data = *p ... DA OK","title":"Dereference a pointer to access data."},{"location":"introduction/#examples","text":"","title":"Examples"},{"location":"introduction/#1-pointer-to-data","text":"data_type v, *pv; pv = &v; // v is a variable, &v is its address data_type a[5], *pa; pa = &a[0] // think logically: a[0] is a variable, &a[0] is its address pa = a // use concisely: a is array name and a = &a[0] v: a normal variable pv: a pointer to a variable v a[]: an array of variables a: array name pa: a pointer to an array","title":"1. Pointer to Data"},{"location":"introduction/#address","text":"constant address (assigned by compiler): &v , &pv , a , &a[0] , &a[1] , ... changeable address variable (changeable during runtime): pv , pa","title":"address"},{"location":"introduction/#data","text":"direct access: v , a[0] , a[1] , ..., f() indirect access: *pv , *pa , pa[0] , *(pa+1) , pa[1] , ..., (*pf)()","title":"data"},{"location":"introduction/#2-pointer-to-function","text":"data_type fd(), (*pfd)(); pfd = &fd; // thinking pfd = fd; // usage data_type *fa(), *(*pfa)(); pfa = &fa; pfa = fa; fd(): a function that returns data fd: function name pfd: a pointer to a funciton fd() fa(): a function that returns address fa: function name pfa: a pointer to a function fa()","title":"2. Pointer to Function"},{"location":"introduction/#address_1","text":"constant address: &fd , fd , &fa , fa changeable address variable: pfd , pfa address returned by fa(): fa() , (*pfa)()","title":"address"},{"location":"introduction/#data_1","text":"data returned by fd(): fd() , (*pfd)()","title":"data"},{"location":"visualization/","text":"Memory Address and Content Memory is used to store data, address, and code. data: variable, array, structure, string, ... address: pointer which points to data or functions code: function Variable If v is a normal variable, &v is the address of v and v is the content of v. &v is fixed. v is changeable. It's obvious that &v and v are different. It's confusing that v is the name of a variable and its content. Data - Array If a[i] is a variable in an array a[] , &a[i] is the address of a[i] and a[i] is the content of a[i]. a[i] is a variable. &a[i] is its address, and a[i] is its content. a is also the address of a[0], so a and &a[0] can be used interchangeably. However, it is convenient but confusing if we use a instead of &a[0] . When coding, there is a trade-off between a and &a[] &a[] : logical, easy to understand a : simple, compact, and concise, but confusing Code - Function If f() is a function, &f is the address of f(), and the content of f() is code. It's confusing that both f and &f are the address of f(). Address - Pointer If p is a pointer variable, &p is the address of p and p is the content of p. both a normal variable and a pointer variable are variables. the difference between a normal variable v and a pointer variable p is that p needs a target. p is the address of the target. *p is the content of the target &p is fixed, p is changeable, and *p is changeable. Pointer to Nothing Pointer to Variable Pointer to Array Pointer to Function Pointer to Pointer to Variable","title":"Visualization"},{"location":"visualization/#memory-address-and-content","text":"Memory is used to store data, address, and code. data: variable, array, structure, string, ... address: pointer which points to data or functions code: function","title":"Memory Address and Content"},{"location":"visualization/#variable","text":"If v is a normal variable, &v is the address of v and v is the content of v. &v is fixed. v is changeable. It's obvious that &v and v are different. It's confusing that v is the name of a variable and its content.","title":"Variable"},{"location":"visualization/#data-array","text":"If a[i] is a variable in an array a[] , &a[i] is the address of a[i] and a[i] is the content of a[i]. a[i] is a variable. &a[i] is its address, and a[i] is its content. a is also the address of a[0], so a and &a[0] can be used interchangeably. However, it is convenient but confusing if we use a instead of &a[0] . When coding, there is a trade-off between a and &a[] &a[] : logical, easy to understand a : simple, compact, and concise, but confusing","title":"Data - Array"},{"location":"visualization/#code-function","text":"If f() is a function, &f is the address of f(), and the content of f() is code. It's confusing that both f and &f are the address of f().","title":"Code - Function"},{"location":"visualization/#address-pointer","text":"If p is a pointer variable, &p is the address of p and p is the content of p. both a normal variable and a pointer variable are variables. the difference between a normal variable v and a pointer variable p is that p needs a target. p is the address of the target. *p is the content of the target &p is fixed, p is changeable, and *p is changeable.","title":"Address - Pointer"},{"location":"visualization/#pointer-to-nothing","text":"","title":"Pointer to Nothing"},{"location":"visualization/#pointer-to-variable","text":"","title":"Pointer to Variable"},{"location":"visualization/#pointer-to-array","text":"","title":"Pointer to Array"},{"location":"visualization/#pointer-to-function","text":"","title":"Pointer to Function"},{"location":"visualization/#pointer-to-pointer-to-variable","text":"","title":"Pointer to Pointer to Variable"},{"location":"workflow/","text":"Workflow Follow the workflow when using a pointer. Target - a useful pointer must points to a target Declaration - data type must be consistant between a pointer and its target Binding - connecting a poniter and a target by assigning the address of a target to a pointer Usage - using *p to access a target of a pointer p Target A pointer without a target is useless, so begin with the target in mind. A target of a pointer could be a variable, an array, a function, another pointer, etc. Declare a target t which will be accessed by a pointer. data_type t; Declaration Declare a pointer p where data type of t and *p must be consistent. data_type *p; Binding Connecting a poniter p and a target t by assigning the address of a target &t to p . p = &t; Usage Dereferencing pointer *p to access t . Examples Point to Variable Point to Char Use a pointer p to set a char variable v to 'A' . Target The target is a char variable v . char v; // data_type of v is char. Declaration char *p; // data_type of v and *p is char where v is a variable and p is a pointer. Binding p = &v; // `p` points to `v` Usage *p = 'A'; // same as v = 'A' Put it together // set v to 'A' char v, *p; p = &v; *p = 'A'; Point to Array Point to an Array of Integers Use a pointer p to access an array a[]. Target The target is an array of integers. int a[] = {0, 10, 2, 3, 4, 5}; // a is array name, a[0], a[1], ... are integer variables Declaration int *p; Binding p = a; // assign array name to a pointer. same as p = &a[0] Usage Set a[0] to 10. *p = 10; // same as p[0]=10 Set a[2] to 32. *(p+2) = 32; // same as p[2]=32 Put it together // set a[0] to 10, and a[2] to 32 int *p, a[] = {0, 10, 2, 3, 4, 5}; p = a; *p = 10; *(p+2) = 32; Point to Pointer Point to a Char Pointer Use a pointer pp to set a char variable v to 'A' . Target The target is a char variable v . char v, *p; // data_type of v and *p is char. Declaration char **pp; // pp is a pointer and data type of **pp is char Binding p = &v; //`p` points to `v` pp = &p; // `pp` points to `p` Usage **pp = 'A'; // same as v = 'A' and *p = `A` Put it together // set v to 'A' char **pp, *p, v; p = &v; pp = &p; **pp = 'A'; // set v to 'A' Point to Function Point to a Function which Returns an Integer Use a pointer p to call a function f() . Target The target is a function f() which returns an integer. int f(); Declaration int (*p)(); // p is a function pointer. calling the function `(*p)()` returns an integer. Binding p = f; // assign function name to a function pointer, same as p = &f Usage (*p)(); // call function f() Put it together // call function f() int (*p)(), f(); p = f; (*p)(); Appendix A Priority of operators in ascending order () [] . -> * & ++ -- + - = += -= Appendix B Function pointer vs function name int h(); // h is function name. Calling h() returns an integer. int (*h)(); // h is a function pointer. Calling function (*p)() will return an integer. int *h(); // h is function name. Calling h() returns an integer pointer int *(*h)(); // h is a function pointer. Calling (*h)() returns an integer pointer","title":"Workflow"},{"location":"workflow/#workflow","text":"Follow the workflow when using a pointer. Target - a useful pointer must points to a target Declaration - data type must be consistant between a pointer and its target Binding - connecting a poniter and a target by assigning the address of a target to a pointer Usage - using *p to access a target of a pointer p","title":"Workflow"},{"location":"workflow/#target","text":"A pointer without a target is useless, so begin with the target in mind. A target of a pointer could be a variable, an array, a function, another pointer, etc. Declare a target t which will be accessed by a pointer. data_type t;","title":"Target"},{"location":"workflow/#declaration","text":"Declare a pointer p where data type of t and *p must be consistent. data_type *p;","title":"Declaration"},{"location":"workflow/#binding","text":"Connecting a poniter p and a target t by assigning the address of a target &t to p . p = &t;","title":"Binding"},{"location":"workflow/#usage","text":"Dereferencing pointer *p to access t .","title":"Usage"},{"location":"workflow/#examples","text":"","title":"Examples"},{"location":"workflow/#point-to-variable","text":"","title":"Point to Variable"},{"location":"workflow/#point-to-char","text":"Use a pointer p to set a char variable v to 'A' .","title":"Point to Char"},{"location":"workflow/#target_1","text":"The target is a char variable v . char v; // data_type of v is char.","title":"Target"},{"location":"workflow/#declaration_1","text":"char *p; // data_type of v and *p is char where v is a variable and p is a pointer.","title":"Declaration"},{"location":"workflow/#binding_1","text":"p = &v; // `p` points to `v`","title":"Binding"},{"location":"workflow/#usage_1","text":"*p = 'A'; // same as v = 'A'","title":"Usage"},{"location":"workflow/#put-it-together","text":"// set v to 'A' char v, *p; p = &v; *p = 'A';","title":"Put it together"},{"location":"workflow/#point-to-array","text":"","title":"Point to Array"},{"location":"workflow/#point-to-an-array-of-integers","text":"Use a pointer p to access an array a[].","title":"Point to an Array of Integers"},{"location":"workflow/#target_2","text":"The target is an array of integers. int a[] = {0, 10, 2, 3, 4, 5}; // a is array name, a[0], a[1], ... are integer variables","title":"Target"},{"location":"workflow/#declaration_2","text":"int *p;","title":"Declaration"},{"location":"workflow/#binding_2","text":"p = a; // assign array name to a pointer. same as p = &a[0]","title":"Binding"},{"location":"workflow/#usage_2","text":"Set a[0] to 10. *p = 10; // same as p[0]=10 Set a[2] to 32. *(p+2) = 32; // same as p[2]=32","title":"Usage"},{"location":"workflow/#put-it-together_1","text":"// set a[0] to 10, and a[2] to 32 int *p, a[] = {0, 10, 2, 3, 4, 5}; p = a; *p = 10; *(p+2) = 32;","title":"Put it together"},{"location":"workflow/#point-to-pointer","text":"","title":"Point to Pointer"},{"location":"workflow/#point-to-a-char-pointer","text":"Use a pointer pp to set a char variable v to 'A' .","title":"Point to a Char Pointer"},{"location":"workflow/#target_3","text":"The target is a char variable v . char v, *p; // data_type of v and *p is char.","title":"Target"},{"location":"workflow/#declaration_3","text":"char **pp; // pp is a pointer and data type of **pp is char","title":"Declaration"},{"location":"workflow/#binding_3","text":"p = &v; //`p` points to `v` pp = &p; // `pp` points to `p`","title":"Binding"},{"location":"workflow/#usage_3","text":"**pp = 'A'; // same as v = 'A' and *p = `A`","title":"Usage"},{"location":"workflow/#put-it-together_2","text":"// set v to 'A' char **pp, *p, v; p = &v; pp = &p; **pp = 'A'; // set v to 'A'","title":"Put it together"},{"location":"workflow/#point-to-function","text":"","title":"Point to Function"},{"location":"workflow/#point-to-a-function-which-returns-an-integer","text":"Use a pointer p to call a function f() .","title":"Point to a Function which Returns an Integer"},{"location":"workflow/#target_4","text":"The target is a function f() which returns an integer. int f();","title":"Target"},{"location":"workflow/#declaration_4","text":"int (*p)(); // p is a function pointer. calling the function `(*p)()` returns an integer.","title":"Declaration"},{"location":"workflow/#binding_4","text":"p = f; // assign function name to a function pointer, same as p = &f","title":"Binding"},{"location":"workflow/#usage_4","text":"(*p)(); // call function f()","title":"Usage"},{"location":"workflow/#put-it-together_3","text":"// call function f() int (*p)(), f(); p = f; (*p)();","title":"Put it together"},{"location":"workflow/#appendix-a","text":"Priority of operators in ascending order () [] . -> * & ++ -- + - = += -=","title":"Appendix A"},{"location":"workflow/#appendix-b","text":"Function pointer vs function name int h(); // h is function name. Calling h() returns an integer. int (*h)(); // h is a function pointer. Calling function (*p)() will return an integer. int *h(); // h is function name. Calling h() returns an integer pointer int *(*h)(); // h is a function pointer. Calling (*h)() returns an integer pointer","title":"Appendix B"}]}